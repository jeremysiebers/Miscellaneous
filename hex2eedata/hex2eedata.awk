##############################################################################
#
#      FILE: hex2eedata.awk
#   PURPOSE: Translate Intel HEX into __EEPROM_DATA() lines
#
#  SYNOPSIS: gawk -f hex2eedata.awk [-v pad=<pad_val>] [-v fmt=<fmt_str>]
#
#  DESCRIPTION:
#
#      This AWK program translates Intel HEX input (stdin or file) into 8-byte
#      __EEPROM_DATA() lines written on stdout with "#include <htc.h>" as the
#      first non-comment line, making the output suitable for redirection to a
#      C file for separate compilation.
#
#      If the "-v pad=<pad_val>" option is specified on the command line, the
#      program uses 'pad_val' to pad the last output line if necessary;
#      otherwise, 0xFF is used as the pad value.
#
#      If the "-v fmt=<fmt_str>" option is specified on the command line, the
#      program uses the string as the printf() format for each __EEPROM_DATA()
#      initializer byte; otherwise, "0x%02X" is used.  For example, for
#      unsigned decimal initializer bytes, one would specify "-v fmt=%3u" on
#      the command line.
#
#      The parts of the input translated are the Data Records between the
#      file's Start Segment Address Record (:02000004...) and its End of File
#      Record (:00000001FF).  This means that arbitrary text may appear
#      outside that range.  Text may be present inside that range as long as
#      it does not appear to be a Data Record (i.e., a ':' followed by only
#      HEX characters and the RECTYP field of "00".  Therefore, the program
#      will ignore comments or documentation added to the input.
#
#  TYPICAL USAGE (redirecting to a C file):
#
#      gawk -f hex2eedata.awk eeprom.hex > eeprom_data.c
#
#  FUNCTIONAL DESCRIPTION:
#
#      The accompanying intelhex.txt file describes Intel HEX format.  The
#      program uses the gawk FIELDWIDTHS extension for the HEX file's
#      fixed-width fields having no distinctive field separator.  The
#      FIELDWIDTHS string is set for a HEX record's fields where:
#
#          ":LLOOOOTTDD...DDCC" represents a record string.
#
#                LL RECLEN field
#              OOOO OFFSET field
#                TT RECTYP field
#                DD DATA.. field(s)
#                CC CHKSUM field
#
#      FIELDWIDTHS = "1 2  4    2  2  ... 2  2"
#                     : LL OOOO TT DD ... DD CC
#      $(field#)      1 2  3    4  5  ...
#
#      Starting with the first Data Record, the program loads the EEPROM byte
#      array ee[] with $2 byte fields ($(5+0) to $(5+($2-1)) inclusive) from
#      each Data Record.  Then it writes __EEPROM_DATA() lines for all ee[]
#      bytes, padding the last line out to 8 bytes if necessary.
#
#  SPECIAL CONSIDERATIONS:
#
#      This program uses gawk extensions (awk alternatives noted):
#
#          FIELDWIDTHS      Alt: substr()
#          HEX constants    Alt: Decimal
#          strtonum()       Alt: A user function
#
#      NOTE: The program assumes that the OFFSET field starts at 0000 and
#            increases each record.  If records are out of order, one can
#            incorporate the OFFSET into ee[] indexing.
#
#      NOTE: The FIELDWIDTHS string is set for data records of 16 bytes or
#            less, but can be expanded if necessary.
#
##############################################################################

# Initialize, optionally with defaults.
#
BEGIN {
    FIELDWIDTHS = "1 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"

    # Set defaults.
    #
    if (fmt == "") fmt = "0x%02X"
    if (pad == "") pad = 0xFF

    # Init globals.
    #
    pad          = strtonum(pad"")
    n_bytes      = 0                    # Byte counter
    line_byte_no = 0                    # Counts modulo-8 bytes per output line
    rec_oh       = 1+2+4+2+2            # MARK, RECLEN, OFFSET, RECTYP, CHKSUM
}

# For each line between the start and end records, load a data record's data
# fields into ee[].
#
/^:02000004[[:xdigit:]]+$/,/^:00000001FF$/ {
    # Data records must be (MARK followed by all HEX chars) &&
    #                      (RECTYPE == 0)                   &&
    #                      (line length appropriate for data byte count)
    if (/^:[[:xdigit:]]+$/ &&
        ($4 == "00")       &&
        (length() == (((rec_len = strtonum("0x"$2)) * 2) + rec_oh))) {
        for (i = 0; i != rec_len; ++i) {
            ee[n_bytes++] = strtonum("0x"$(5 + i))
        }
    }
}

# Finish by writing ee[] as 8-byte __EEPROM_DATA() lines.
#
END {
    print "/* Auto-generated by hex2eedata.awk from", FILENAME, "on"
    print " * " strftime("%b %d %H:%M:%S %Y")
    print " */"

    # Include the header defining the __EEPROM_DATA() macro.
    #
    print "#include <htc.h>\n"

    # Write EEPROM initializer lines.  If the last line's last byte is not on
    # an 8-byte boundary, pad it.
    #
    for (n = 0; n != n_bytes; ++n) {
        if (line_byte_no == 0) {
            printf("/* %04X: */__EEPROM_DATA(", n)
        }
        print_byte(ee[n])
    }
    while (line_byte_no != 0) {
        print_byte(pad)
    }
}

# print_byte(b) prints 'b', handling byte separation or line termination by
# incrementing line_byte_no modulo 8.
#
function print_byte(b) {
    if (++line_byte_no != 8) {
        printf(fmt ", ", b)
    } else {
        printf(fmt ");\n", b)
        line_byte_no = 0;
    }
}
